<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>College Basketball Conference Clinching Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1);
            padding: 30px;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 3px solid #667eea;
        }

        h1 {
            color: #333;
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #666;
            font-size: 1.1em;
        }

        .conference-section {
            margin-bottom: 40px;
        }

        .conference-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 20px;
            border-radius: 8px 8px 0 0;
            font-size: 1.3em;
            font-weight: bold;
        }

        .standings-table {
            width: 100%;
            border-collapse: collapse;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .standings-table th {
            background-color: #f8f9fa;
            padding: 12px;
            text-align: left;
            font-weight: 600;
            color: #333;
            border-bottom: 2px solid #dee2e6;
        }

        .standings-table td {
            padding: 12px;
            border-bottom: 1px solid #dee2e6;
        }

        .standings-table tr:hover {
            background-color: #f8f9fa;
        }

        .clinched {
            background-color: #28a745 !important;
            color: white;
            font-weight: bold;
        }

        .clinched:hover {
            background-color: #218838 !important;
        }

        .team-rank {
            font-weight: bold;
            color: #667eea;
        }

        .loading {
            text-align: center;
            padding: 40px;
            font-size: 1.2em;
            color: #666;
        }

        .error {
            background-color: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            border: 1px solid #f5c6cb;
        }

        .last-updated {
            text-align: center;
            color: #666;
            margin-top: 20px;
            font-style: italic;
        }

        .legend {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 30px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .legend-box {
            width: 30px;
            height: 20px;
            border-radius: 4px;
        }

        .legend-clinched {
            background-color: #28a745;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.8em;
            }

            .standings-table {
                font-size: 0.9em;
            }

            .standings-table th,
            .standings-table td {
                padding: 8px 4px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üèÄ College Basketball Conference Clinching Dashboard</h1>
            <p class="subtitle">Live Conference Standings & Clinching Status</p>
        </header>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-box legend-clinched"></div>
                <span>Conference Clinched</span>
            </div>
        </div>

        <div id="dashboard" class="loading">
            Loading conference standings...
        </div>

        <div class="last-updated" id="lastUpdated"></div>
    </div>

    <script>
        // Conference configuration with total conference games
        const CONFERENCE_GAMES = {
            'America East': 16,
            'American Conference': 18,
            'Atlantic 10': 18,
            'Atlantic Coast': 20,
            'Atlantic Sun': 18,
            'Big East': 20,
            'Big Ten': 20,
            'Big 12': 20,
            'Big Sky': 18,
            'Big South': 18,
            'Big West': 20,
            'Coastal Athletic': 18,
            'Conference USA': 20,
            'Horizon': 20,
            'Ivy League': 14,
            'Metro Atlantic Athletic': 20,
            'Mid-American': 18,
            'Mid-Eastern': 14,
            'Missouri Valley': 20,
            'Mountain West': 20,
            'Northeast': 16,
            'Ohio Valley': 20,
            'Patriot League': 18,
            'Southeastern': 20,
            'Southern': 18,
            'Southland': 20,
            'Southwestern Athletic': 18,
            'Summit League': 16,
            'Sun Belt': 18,
            'West Coast': 18,
            'Western Athletic': 16
        };

        const API_URL = 'https://prod.origin.api.stats.com/v1/stats/basketball/cbk/standings';
        let isFetching = false;

        // Function to check if a team has clinched their conference
        function hasTeamClinched(team, teams, conferenceGames) {
            if (!teams || teams.length < 2) return false;

            // Sort teams by conference wins (descending)
            const sortedTeams = [...teams].sort((a, b) => {
                const aConfWins = parseInt(a.conferenceWins || 0);
                const bConfWins = parseInt(b.conferenceWins || 0);
                return bConfWins - aConfWins;
            });

            // Get the first place team
            const firstPlaceTeam = sortedTeams[0];
            
            // If this team is not in first place, it hasn't clinched
            if (team.teamId !== firstPlaceTeam.teamId) {
                return false;
            }

            // Check if there's a second place team
            if (sortedTeams.length < 2) return false;

            const secondPlaceTeam = sortedTeams[1];
            
            const firstPlaceWins = parseInt(firstPlaceTeam.conferenceWins || 0);
            const secondPlaceWins = parseInt(secondPlaceTeam.conferenceWins || 0);
            const secondPlaceLosses = parseInt(secondPlaceTeam.conferenceLosses || 0);
            
            // Calculate maximum possible wins for second place team
            const secondPlaceGamesPlayed = secondPlaceWins + secondPlaceLosses;
            const secondPlaceGamesRemaining = conferenceGames - secondPlaceGamesPlayed;
            const secondPlaceMaxWins = secondPlaceWins + secondPlaceGamesRemaining;
            
            // Team clinches if their current wins exceed second place's maximum possible wins
            return firstPlaceWins > secondPlaceMaxWins;
        }

        // Function to calculate games back
        function calculateGamesBack(team, leader) {
            const teamWins = parseInt(team.conferenceWins || 0);
            const teamLosses = parseInt(team.conferenceLosses || 0);
            const leaderWins = parseInt(leader.conferenceWins || 0);
            const leaderLosses = parseInt(leader.conferenceLosses || 0);
            
            const gb = ((leaderWins - teamWins) + (teamLosses - leaderLosses)) / 2;
            return gb === 0 ? '-' : gb.toFixed(1);
        }

        // Function to render conference standings
        function renderConferenceStandings(conferenceName, teams, conferenceGames) {
            // Sort teams by conference record
            const sortedTeams = [...teams].sort((a, b) => {
                const aWins = parseInt(a.conferenceWins || 0);
                const bWins = parseInt(b.conferenceWins || 0);
                const aLosses = parseInt(a.conferenceLosses || 0);
                const bLosses = parseInt(b.conferenceLosses || 0);
                
                // First by wins
                if (bWins !== aWins) return bWins - aWins;
                // Then by losses
                return aLosses - bLosses;
            });

            const leader = sortedTeams[0];

            let html = `
                <div class="conference-section">
                    <div class="conference-header">${conferenceName}</div>
                    <table class="standings-table">
                        <thead>
                            <tr>
                                <th>Rank</th>
                                <th>Team</th>
                                <th>Overall Record</th>
                                <th>Conference Record</th>
                                <th>Games Back</th>
                            </tr>
                        </thead>
                        <tbody>
            `;

            sortedTeams.forEach((team, index) => {
                const hasClinched = hasTeamClinched(team, sortedTeams, conferenceGames);
                const clinchClass = hasClinched ? 'clinched' : '';
                const overallRecord = `${team.overallWins || 0}-${team.overallLosses || 0}`;
                const confRecord = `${team.conferenceWins || 0}-${team.conferenceLosses || 0}`;
                const gamesBack = calculateGamesBack(team, leader);
                
                html += `
                    <tr class="${clinchClass}">
                        <td class="team-rank">${index + 1}</td>
                        <td>${team.teamName || 'Unknown'}</td>
                        <td>${overallRecord}</td>
                        <td>${confRecord}</td>
                        <td>${gamesBack}</td>
                    </tr>
                `;
            });

            html += `
                        </tbody>
                    </table>
                </div>
            `;

            return html;
        }

        // Function to fetch and display standings
        async function fetchStandings() {
            if (isFetching) {
                console.log('Already fetching data, skipping...');
                return;
            }

            isFetching = true;
            const dashboardDiv = document.getElementById('dashboard');

            try {
                const response = await fetch(API_URL);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                
                let html = '';

                // Process each conference
                for (const [conferenceName, conferenceGames] of Object.entries(CONFERENCE_GAMES)) {
                    // Find the conference in the API data
                    const conferenceData = data.conferences?.find(c => 
                        c.conferenceName === conferenceName
                    );

                    if (conferenceData && conferenceData.teams && conferenceData.teams.length > 0) {
                        html += renderConferenceStandings(conferenceName, conferenceData.teams, conferenceGames);
                    } else {
                        // Conference not found or has no teams
                        html += `
                            <div class="conference-section">
                                <div class="conference-header">${conferenceName}</div>
                                <div style="padding: 20px; text-align: center; color: #666;">
                                    No standings data available
                                </div>
                            </div>
                        `;
                    }
                }

                dashboardDiv.innerHTML = html;

                // Update last updated time
                const now = new Date();
                document.getElementById('lastUpdated').textContent = 
                    `Last updated: ${now.toLocaleString()}`;

            } catch (error) {
                console.error('Error fetching standings:', error);
                dashboardDiv.innerHTML = `
                    <div class="error">
                        <strong>Error loading standings:</strong> ${error.message}
                        <br>
                        <small>The dashboard will retry in 5 minutes.</small>
                    </div>
                `;
            } finally {
                isFetching = false;
            }
        }

        // Initial load
        fetchStandings();

        // Auto-refresh every 5 minutes
        setInterval(fetchStandings, 5 * 60 * 1000);
    </script>
</body>
</html>
